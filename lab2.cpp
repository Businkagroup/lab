#include <stdlib.h>
#include <iostream>
//Директивы препроцессора, включающие заголовочные файлы

struct TwoInts
{
    int a;
    int b;
};

//Здесь объявляется пременная TwoInts с типом данных struct
// Struct - это составной пользовательский тип данных
// В данном случае он состоит из двух целочисленных переменных с названиями a и b

struct StructWithArray
{
    int arr[4];
    int* someNumber;
};
//Еще один Struct в котором объявлен массив из 5ти целочисленных значений и указатель на целочисленное значение someNumber

int main()
{
    TwoInts i2 = { };
    i2.a = 5;
    i2.b = 7;

//Здесь объявляется пременная типа пользовательского TwoInts с именем i2
//Затем переменным a и b внутри нее присваиваются значения 5 и 7 соответственно

    std::cout << i2.a << std::endl;
    std::cout << i2.b << std::endl;

//Значения переменных a и b выводятся в консоль функцией (объектом?(я не знаю что такое ооп)) cout и начинают новую строку при помощи endl
//К слову, мы имеем возможность использовать cout благодаря тому, что мы подключили файл iostream

    StructWithArray s = { };
    s.arr[0] = 10;

//Здесь инициализируется переменная типа StructWithArray с именем s
//Затем в элемент массива с индексом 0 (1 по порядку) помещается значение 10

    StructWithArray s1 = { };
    s1.arr[0] = 15;

//Все тоже самое только объявляется переменная с другим названием и в массив передается другое значение

    StructWithArray* sPointer = &s;
    sPointer->arr[0] = 20;

//Здесь обявляется указатель с типом StructWithArray  с название sPointer, указывающим на адрес переменной s в оперативной памяти
//Затем при помощи указателя в первый элмент массива передается значение 20

    std::cout << s.arr[0] << std::endl;

//Здесь мы выводим первый элемент массива из переменной s, что равняется 20
//Ранее этот элемент равнялся 15, но пот ом через указатель мы изменили его на 20

    s.arr[0] = 25;
    std::cout << s.arr[0] << std::endl;

//Здесь мы напрямую устанавливаем значение первого элемента на 25 и выводим его

    sPointer->arr[0] = 30;
    std::cout << s.arr[0] << std::endl;

//Здесь мы при помощи указателя устанавливаем первому члену массива значение 30 и выводим на экран

    sPointer = &s1;
    sPointer->arr[0] = 35;

//Здесь мы присваем указателю sPointer на адрес переменной s1, и передаем в первый элемент число 35, раньше там было 15


    std::cout << s.arr[0] << std::endl;
    std::cout << s1.arr[0] << std::endl;

//Выводим значения первых элементов массивов из структур s и s1

    StructWithArray structArray[2] = { };
    structArray[0].arr[3] = 77;
    structArray[1].someNumber = &structArray[0].arr[3];

    sPointer = &s;
    int* pointer = &sPointer->arr[3];
    s.arr[3] = 72;
//Передаем адрес s в качестве значения указателю sPointer (чуть выше он указывал на s1)
//Создаем новый указатель который указывает на указатель sPointer который ссылается на 4 элемент массива
//4 элемент делаем равным 72
    std::cout << *pointer;
//Здесь автор хотел показать так называемый derefference при работе с указателями, а так же то, что указатель может указывать на указатель (https://www.meme-arsenal.com/memes/be9f6d46d5470b73e4d441c5c9288156.jpg)
//std::cout << *pointer; <----- Здесь мы выводим не значение самого указателя, так как значение указателя это адрес памяти
// а выводим значение переменной на которую ссылается указатель
// вот например если мы выведем значение указателя таким образом
//                    std::cout << pointer;
//то получим адрес в шестнадцатиричном формате вместо конечного ответа чему же все таки равно arr[3]
    //StructWithArray memory;
    //memset(&memory, 0, sizeof(StructWithArray));
    return 0;
}
